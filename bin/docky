#!/bin/bash

DOCKY_VERSION="0.1.0-dev"
DOCKY_RELEASE_DATE="Jul 21, 2017"
DOCKY_EXECUTABLE_COMMANDS=("doc" "up" "build" "version")
SUPPORTED_PLATFORMS=("woocommerce" "magento" "eccube")
REPOSITORY_ACCOUNT="https://github.com/guzzilar"
VERSIONING_LOCATION=".version"

app_name=""
build_location=""
build_platform=""
build_source=""
build_version="latest"
container_base_location="containers"
container_location=""

the_command=""
arg_position=0

###
 # Docky's document
 ##
doc () {
    echo -e "Docky Document:"
    echo -e "---------------"
    echo -e "usage: docky build [<name>] [--version=<version>]"
    echo -e ""
    echo -e "\t--version\tSpecify the target version that you want to build"
}

###
 # Docky's version
 ##
version () {
    echo -e ".."
    echo -e "Docky v$DOCKY_VERSION (released at $DOCKY_RELEASE_DATE)"
}

###
 # Check if Docky supports a build target platform.
 #
 # @param $1 string  name of a platform you want to check
 ##
canExecute () {
    local the_command

    for the_command in ${DOCKY_EXECUTABLE_COMMANDS[@]}; do
        [[ $the_command == $1 ]] && {
            return 0
        }
    done

    return 1
}

###
 # Check if Docky supports a build target platform.
 #
 # @param $1 string  name of a platform you want to check
 ##
isSupportPlatform () {
    local platform

    for platform in ${SUPPORTED_PLATFORMS[@]}; do
        [[ $platform == $1 ]] && {
            return 0
        }
    done

    return 1
}

###
 # Container version checking
 ##
fetchContainer () {
    local container_version=$(curl -s https://api.github.com/repos/guzzilar/docker-$build_platform/git/refs/heads/master | jq '.object.sha' | sed -e 's/^"//' -e 's/"$//')
    container_location=$container_base_location/$build_platform

    echo "Docky: checking the container version.."

    # Check for base container directory.
    if [ ! -d $container_location ]; then
        mkdir -p $container_location
        echo " > Created a $container_location directory."
    fi

    # Check for container versioning directory.
    if [ ! -d $container_base_location/.versions ]; then
        mkdir -p $container_base_location/.versions
        echo " > Created a $container_base_location/.versions directory."
    fi

    # Cache a versioning file.
    if [ ! -f "$container_base_location/.versions/docker-$build_platform.$container_version" ]; then
        echo " > Found a new version of docker-$build_platform (commit: $container_version)"

        rm -f $container_base_location/.versions/docker-$build_platform.*
        touch $container_base_location/.versions/docker-$build_platform.$container_version

        echo " > Cached \"$container_base_location/.versions/docker-$build_platform.$container_version\""
    else
        echo " > The container is up-to-date."
    fi
}

###
 # Preparation
 ##
initialize () {
    local package_location="$REPOSITORY_ACCOUNT/docker-$build_platform/archive/master.zip"
    build_location="app/$([[ ! -z $app_name ]] && echo $app_name || echo $build_platform)"

    fetchContainer

    echo ".."
    echo "."
    echo "Docky: preparing docker..."

    if [ ! -d $build_location ]; then
        mkdir -p $build_location
        echo " > Created a $build_location directory."
    else
        echo " > Cannot create a new app, $build_location already exists."
    fi

    [[ ! -d $container_location/src && ! -f $container_location/tmp/docker-$build_platform.zip ]] && {
        # 1. Download.
        mkdir $container_location/tmp
        echo "Docky: downloading a Docker package from $package_location."
        echo "Docky: ================================================================================"
        wget -O $container_location/tmp/docker-$build_platform.zip $package_location

        # 2. Unzip
        echo "Docky: unzip $container_location/tmp/docker-$build_platform.zip"
        echo "Docky: ================================================================================"
        unzip $container_location/tmp/docker-$build_platform.zip -d $container_location/tmp/
        echo "Docky: moving file to $container_location."
        mv $container_location/tmp/docker-$build_platform-master/* $container_location
    }
}

##
# Boot up a container!
#
up() {
    echo ".."
    echo "Docky: running up \"$build_platform\" version \"$build_version\" container.."

    initialize

    echo "Docky: Booting up the docker!"
    echo "Docky: ================================================================================"

    $container_location/bin/docky-servant up $build_version $build_location
}

##
# Build it!
#
build() {
    echo ".."
    echo "Docky: running up \"$build_platform\" version \"$build_version\" container.."

    initialize

    echo "Docky: Booting up the docker!"
    echo "Docky: ================================================================================"

    $container_location/bin/docky-servant build $build_version $build_location
}

# ..
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-
# EXECUTION AREA
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-
# ..
the_command=$1
if ! canExecute $the_command; then
    echo ".."
    echo "Docky: error, cannot execute \"$the_command\"."
    echo ""
    doc
    exit
fi

# Remove "execute command" from arguments.
shift

# Reading arguments.
while [[ $# -gt 0 ]]; do
    case "$1" in
        --version=*)
            build_version="${1#*=}"
            shift
            ;;

        --source=*)
            build_source="${1#*=}"
            shift
            ;;

        *)
            [[ -z $build_platform ]] && {
                OIFS=$IFS
                IFS=":"
                target=($1)

                if ! isSupportPlatform ${target[0]}; then
                    echo ".."
                    echo "Docky: error, platform \"$1\" did not match with any platform(s) I supported."
                    exit
                fi

                build_platform=${target[0]}
                build_version=$([[ ! -z ${target[1]} ]] && echo ${target[1]} || echo "latest")

                IFS=$OIFS
                arg_position=1

                shift
                continue
            }

            [[ $arg_position -eq 1 ]] && {
                app_name=$1

                shift
                continue
            }
            ;;
    esac
done

$the_command

# [[ ! -z $build_platform ]] && {
    # $execute_command
# }
